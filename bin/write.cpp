//  :copyright: (c) 2015-2016 The Regents of the University of California.
//  :license: MIT, see LICENSE.md for more details.
/*
 *  \addtogroup AutoCOM
 *  \brief Write class attributes into C++ interface.
 */

#include "write.hpp"

#include <fstream>
#include <ostream>


namespace autocom
{
// FUNCTIONS
// ---------


/** \brief Write documentation string for library to file.
 */
void writeDocString(std::ostream &stream)
{
    stream << "/**\r\n"
           << " *            **DO NOT EDIT THIS FILE**              \r\n"
           << " *  This file was automatically generated by AutoCOM.\r\n"
           << " *  Any changes to this file will be overwritten.    \r\n"
           << " */\r\n"
           << "\r\n";
}


/** \brief Write import statement for file.
 */
void writeImportStatement(std::ostream &stream,
    TypeLibDescription &tlib)
{
    stream << "#include \"" << tlib.guid.uuid() << ".hpp\"\r\n";
}


/** \brief Write section for C++
 */
template <typename Container>
void writeSection(std::ostream &stream,
    const Container &container,
    const std::string &comment)
{
    stream << "// " << comment << "\r\n"
           << "// " << std::string(comment.size(), '-') << "\r\n"
           << "\r\n";

    for (const auto &item : container) {
        stream << item.header() << "\r\n";
    }
    stream << "\r\n";
}



/** \brief Write forward declarations.
 */
void writeForwardDeclarations(std::ostream &stream,
    TypeLibDescription &tlib)
{
    stream << "// FORWARD\r\n"
           << "// -------\r\n"
           << "\r\n";

    for (const auto &item: tlib.description.unions) {
        stream << item.forward() << "\r\n";
    }
    for (const auto &item: tlib.description.records) {
        stream << item.forward() << "\r\n";
    }
    for (const auto &item: tlib.description.interfaces) {
        stream << item.forward() << "\r\n";
    }
    for (const auto &item: tlib.description.dispatchers) {
        stream << item.forward() << "\r\n";
    }
    for (const auto &item: tlib.description.coclasses) {
        stream << item.forward() << "\r\n";
    }
    for (const auto &item: tlib.description.aliases) {
        stream << item.header() << "\r\n";
    }
    stream << "\r\n";
}


/** \brief Write typedefs for function signatures.
 */
void writeMethodSignatures(std::ostream &stream,
    TypeLibDescription &tlib)
{
    stream << "namespace signatures"
           << "{\r\n"
           << "// SIGNATURES\r\n"
           << "// ----------\r\n"
           << "\r\n";

    for (const auto &item: tlib.description.interfaces) {
        stream << item.signatures() << "\r\n";
    }
    for (const auto &item: tlib.description.dispatchers) {
        stream << item.signatures() << "\r\n";
    }

    stream << "}   /* signatures */\r\n";
}


/** \brief Write human-friendly import library.
 */
std::string writeImportHeader(TypeLibDescription &tlib,
    std::string &directory)
{
    // get path
    auto name = tlib.documentation.name + ".hpp";
    std::string path = directory + "\\" + name;
    std::ofstream stream(path, std::ios::binary);

    // write import
    writeDocString(stream);
    writeImportStatement(stream, tlib);

    return path;
}


/** \brief Write header with unique CLSID as an identifier.
 */
std::string writeClsidHeader(TypeLibDescription &tlib,
    std::string &ns,
    std::string &directory)
{
    auto name = tlib.guid.uuid() + ".hpp";
    std::string path = directory + "\\" + name;
    std::ofstream stream(path, std::ios::binary);

    // write data
    writeDocString(stream);
    stream << "#include <autocom.hpp>\r\n\r\n";
    if (!ns.empty()) {
        stream << "namespace " << ns << "\r\n"
               << "{\r\n\r\n";
    }
    stream << tlib.guid.define("CLSID", tlib.documentation.name) << "\r\n\r\n";

    // SIMPLE
    writeSection(stream, tlib.description.enums, "ENUMS");
    writeForwardDeclarations(stream, tlib);
    writeSection(stream, tlib.description.unions, "UNIONS");

    // CLASSES
    writeSection(stream, tlib.description.records, "STRUCTS");
    writeSection(stream, tlib.description.interfaces, "INTERFACES");
    writeSection(stream, tlib.description.dispatchers, "DISPATCHERS");
    writeSection(stream, tlib.description.coclasses, "COCLASSES");

    // FUNCTION SIGNATURES
    writeMethodSignatures(stream, tlib);

    if (!ns.empty()) {
        stream << "}   /* " << ns << " */\r\n";
    }

    return path;
}


/** \brief Write C++ header file from TypeLib description.
 */
void writeHeaders(TypeLibDescription &tlib,
    std::string &ns,
    std::string &directory,
    Files &files)
{
    files.headers.emplace_back(writeImportHeader(tlib, directory));
    files.headers.emplace_back(writeClsidHeader(tlib, ns, directory));
}


}   /* autocom */
